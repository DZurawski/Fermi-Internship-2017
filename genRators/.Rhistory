write.csv(
initial.frame %>%
mutate(phi = atan2(y, x)) %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(r = sqrt(x * x + y * y)) %>%
mutate(z = (r / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z),
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
require("tidyr")
require("dplyr")
initial.frame <- read.csv("../datasets/public_train_100MeV.csv")
z.bounds   <- c(-200, 200) # What should the min and max z values be?
layer.max  <- max(initial.frame$layer) + 1
eta.bounds <- c(atan(layer.max / z.bounds[1] - pi),
atan(layer.max / z.bounds[1]),
atan(layer.max / z.bounds[2]),
atan(layer.max / z.bounds[2] + pi))
stopifnot(eta.bounds[1] < eta.bounds[2]) # runif doesn't work correctly
stopifnot(eta.bounds[3] < eta.bounds[4]) # if these conditions are false.
write.csv(
initial.frame %>%
mutate(phi = atan2(y, x)) %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(r = sqrt(x * x + y * y)) %>%
mutate(z = (r / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z),
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
require("tidyr")
require("dplyr")
initial.frame <- read.csv("../datasets/public_train_100MeV.csv")
z.bounds      <- c(-200, 200) # What should the min and max z values be?
layer.max     <- max(initial.frame$layer) + 1
eta.bounds    <- c(atan(layer.max / z.bounds[1] - pi),
atan(layer.max / z.bounds[1]),
atan(layer.max / z.bounds[2]),
atan(layer.max / z.bounds[2] + pi))
stopifnot(eta.bounds[1] < eta.bounds[2]) # runif doesn't work correctly
stopifnot(eta.bounds[3] < eta.bounds[4]) # if these conditions are false.
write.csv(
initial.frame %>%
mutate(phi = atan2(y, x)) %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(r = floor(sqrt(x * x + y * y))) %>%
mutate(z = (r / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z),
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
require("tidyr")
require("dplyr")
initial.frame <- read.csv("../datasets/public_train_100MeV.csv")
z.bounds      <- c(-200, 200) # What should the min and max z values be?
layer.max     <- max(initial.frame$layer) + 1
eta.bounds    <- c(atan(layer.max / z.bounds[1] - pi),
atan(layer.max / z.bounds[1]),
atan(layer.max / z.bounds[2]),
atan(layer.max / z.bounds[2] + pi))
stopifnot(eta.bounds[1] < eta.bounds[2]) # runif doesn't work correctly
stopifnot(eta.bounds[3] < eta.bounds[4]) # if these conditions are false.
write.csv(
initial.frame %>%
mutate(phi = atan2(y, x)) %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(r = round(sqrt(x * x + y * y))) %>%
mutate(z = (r / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z),
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
require("tidyr")
require("dplyr")
initial.frame <- read.csv("../datasets/public_train_100MeV.csv")
z.bounds      <- c(-200, 200) # What should the min and max z values be?
layer.max     <- max(initial.frame$layer)
eta.bounds    <- c(atan(layer.max / z.bounds[1] - pi),
atan(layer.max / z.bounds[1]),
atan(layer.max / z.bounds[2]),
atan(layer.max / z.bounds[2] + pi))
stopifnot(eta.bounds[1] < eta.bounds[2]) # runif doesn't work correctly
stopifnot(eta.bounds[3] < eta.bounds[4]) # if these conditions are false.
write.csv(
initial.frame %>%
mutate(phi = atan2(y, x)) %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(r = round(sqrt(x * x + y * y))) %>%
mutate(z = ((layer + 1) / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z),
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
write.csv(
initial.frame %>%
mutate(phi = atan2(y, x)) %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(z = ((r) / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z),
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
require("tidyr")
require("dplyr")
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = round(sqrt(x * x + y * y)))
z.bounds      <- c(-200, 200) # What should the min and max z values be?
r.max     <- max(initial.frame$r)
eta.bounds    <- c(atan(r.max / z.bounds[1] - pi),
atan(r.max / z.bounds[1]),
atan(r.max / z.bounds[2]),
atan(r.max / z.bounds[2] + pi))
stopifnot(eta.bounds[1] < eta.bounds[2]) # runif doesn't work correctly
stopifnot(eta.bounds[3] < eta.bounds[4]) # if these conditions are false.
write.csv(
initial.frame %>%
mutate(phi = atan2(y, x)) %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(z = ((r) / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z),
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
require("tidyr")
require("dplyr")
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = round(sqrt(x * x + y * y), 3))
z.bounds      <- c(-200, 200) # What should the min and max z values be?
r.max     <- max(initial.frame$r)
eta.bounds    <- c(atan(r.max / z.bounds[1] - pi),
atan(r.max / z.bounds[1]),
atan(r.max / z.bounds[2]),
atan(r.max / z.bounds[2] + pi))
stopifnot(eta.bounds[1] < eta.bounds[2]) # runif doesn't work correctly
stopifnot(eta.bounds[3] < eta.bounds[4]) # if these conditions are false.
write.csv(
initial.frame %>%
mutate(phi = atan2(y, x)) %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(z = ((r) / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z),
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
print(unique(intial.frame$r))
print(unique(initial.frame$r))
require("tidyr")
require("dplyr")
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = round(sqrt(x * x + y * y), 3))
initial.frame$r
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = sqrt(x * x + y * y), 3)
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = sqrt(x * x + y * y), 3)
initial.frame$r
sqrt(5)
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = sqrt(x * x + y * y))
initial.frame$r
initial.frame
unique(initial.frame$r)
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = sqrt(x * x + y * y))
unique(initial.frame$r)
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = round(sqrt(x * x + y * y), 5))
unique(initial.frame$r)
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = round(sqrt(x * x + y * y), 10))
unique(initial.frame$r)
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = round(sqrt(x * x + y * y), 8))
unique(initial.frame$r)
options(digits=10)
unique(initial.frame$r)
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(r = round(sqrt(x * x + y * y), 6))
unique(initial.frame$r)
require("tidyr")
require("dplyr")
z.bounds      <- c(-200, 200) # What should the min and max z values be?
initial.frame <- read.csv("../datasets/public_train_100MeV.csv") %>%
mutate(phi = atan2(y, x)) %>%
mutate(r = round(sqrt(x * x + y * y), 6))
r.max         <- max(initial.frame$r)
eta.bounds    <- c(atan(r.max / z.bounds[1] - pi),
atan(r.max / z.bounds[1]),
atan(r.max / z.bounds[2]),
atan(r.max / z.bounds[2] + pi))
stopifnot(eta.bounds[1] < eta.bounds[2]) # runif doesn't work correctly
stopifnot(eta.bounds[3] < eta.bounds[4]) # if these conditions are false.
initial.frame <-initial.frame %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(z = ((r) / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z)
write.csv(
initial.frame,
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
write.csv(
initial.frame,
"../datasets/standard_curves100MeV.csv",
row.names = TRUE
)
print(unique(initial.frame$r))
print(sort(unique(initial.frame$r)))
print("HEllo")
require("tidyr")
require("dplyr")
z.bounds      <- c(-200, 200) # What should the min and max z values be?
initial.frame <- read.csv("../datasets/uniform_train.csv") %>%
mutate(phi = atan2(y, x)) %>%
mutate(r = round(sqrt(x * x + y * y), 6))
initial.frame <- read.csv("../datasets/uniform_train.csv") %>%
mutate(phi = atan2(y, x)) %>%
mutate(r = round(sqrt(x * x + y * y), 6))
r.max         <- max(initial.frame$r)
eta.bounds    <- c(atan(r.max / z.bounds[1] - pi),
atan(r.max / z.bounds[1]),
atan(r.max / z.bounds[2]),
atan(r.max / z.bounds[2] + pi))
stopifnot(eta.bounds[1] < eta.bounds[2]) # runif doesn't work correctly
stopifnot(eta.bounds[3] < eta.bounds[4]) # if these conditions are false.
initial.frame <-initial.frame %>%
group_by(event_id, cluster_id) %>%
mutate(eta = sample(c(runif(1, eta.bounds[1], eta.bounds[2]),
runif(1, eta.bounds[3], eta.bounds[4])), 1)) %>%
ungroup() %>%
mutate(z = ((r) / tan(eta))) %>%
arrange(event_id, cluster_id, layer) %>%
select(event_id, cluster_id, r, phi, z)
write.csv(
initial.frame,
"../datasets/uniform_train_with_z.csv",
row.names = TRUE
)
print(sort(unique(initial.frame$r)))
