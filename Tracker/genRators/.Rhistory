install.packages("tidyverse")
require("tidyr")
require("dplyr")
require("rgl")
require("tidyr")
require("dplyr")
require("rgl")
hits.tot<-20
hits<-data.frame(id=1:hits.tot,z=runif(hits.tot,-50,50), phi=runif(hits.tot,0,2*pi),eta=runif(hits.tot,0,2*pi))
hits<-hits %>% mutate(z1.40=40/tan(eta),z2.70=70/tan(eta),z25.100=100/tan(eta),z3.130=130/tan(eta))
hits<-hits %>% gather(key=layer,value=zl,z1.40:z3.130) %>% separate(layer, into = c("val", "r"), sep = "\\.")
hits<-hits %>% transform(r=as.numeric(r)) %>% filter(zl+z<200 & zl+z>-200)
plot3d(sin(hits$phi)*hits$r, cos(hits$phi)*hits$r, hits$zl + hits$z, col=hits$id, type='p')
require("tidyr")
require("dplyr")
hits.total <- 10 # Assign this value to the hits.total variable.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that...
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
#hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
hits
hits.total <- 10 # Assign this value to the hits.total variable.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that...
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
hits
hits.total <- 10 # Assign this value to the hits.total variable.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that...
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
hits<-hits %>% transform(r=as.numeric(r)) %>% filter(zl+z<200 & zl+z>-200)
hits
hits.total <- 10 # Assign this value to the hits.total variable.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that...
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
#hits<-hits %>% transform(r=as.numeric(r)) %>% filter(zl+z<200 & zl+z>-200)
hits
hits.total <- 10 # Assign this value to the hits.total variable.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that...
#hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
#hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
#hits<-hits %>% transform(r=as.numeric(r)) %>% filter(zl+z<200 & zl+z>-200)
hits
hits.total <- 10 # Assign this value to the hits.total variable.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that...
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
#hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
#hits<-hits %>% transform(r=as.numeric(r)) %>% filter(zl+z<200 & zl+z>-200)
hits
hits.total <- 10 # Assign this value to the hits.total variable.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
hits
# Gather is a function that
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
#hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
#hits<-hits %>% transform(r=as.numeric(r)) %>% filter(zl+z<200 & zl+z>-200)
hits
hits.total <- 10 # Assign this value to the hits.total variable.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that takes multiple columns and colapses them into key-value pairs.
# The below code takes the columns z1.40 through z3.130 and creates two new columns, 'layer' and 'zl'.
# The 'layer' column consists of many iterations of names of the collapsed columns as keys.
# The 'zl' column consists of values from the collapsed columns, which serve as keys.
# The columns, z1.40 through z3.130 are then removed from the data frame.
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
#hits<-hits %>% transform(r=as.numeric(r)) %>% filter(zl+z<200 & zl+z>-200)
hits
hits.total <- 10 # Assign this value to the hits.total variable.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that takes multiple columns and colapses them into key-value pairs.
# The below code takes the columns z1.40 through z3.130 and creates two new columns, 'layer' and 'zl'.
# The 'layer' column consists of many iterations of names of the collapsed columns as keys.
# The 'zl' column consists of values from the collapsed columns, which serve as keys.
# The columns, z1.40 through z3.130 are then removed from the data frame.
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
hits
hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
#hits<-hits %>% transform(r=as.numeric(r)) %>% filter(zl+z<200 & zl+z>-200)
hits
hits.total <- 10 # Assign this value to the hits.total variable. In R, '<-' is used for assignment.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that takes multiple columns and colapses them into key-value pairs.
# The below code takes the columns z1.40 through z3.130 and creates two new columns, 'layer' and 'zl'.
# The 'layer' column consists of many iterations of names of the collapsed columns as keys.
# The 'zl' column consists of values from the collapsed columns, which serve as keys.
# The columns, z1.40 through z3.130 are then removed from the data frame.
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
# Separate does just that: it separates a column (in this case, layer) into two or more columns,
# specified using the 'into' argument. The layer column is separated by the '.' character.
hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
# Transform essentially changes a column into a different data type.
# In this context, the 'r' column is originally a string. r=as.numeric(r) changes it into a number type.
hits <- hits %>% transform(r=as.numeric(r))
# Filter returns all rows such that the condition specified as an argument is true.
# Here, we assign make a data frame consisting of all the hits such that: (zl + z < 200 & zl + z > -200).
hits <- hits %>% filter(zl+z<200 & zl+z>-200)
hits
?mutate
hits.total <- 10 # Assign this value to the hits.total variable. In R, '<-' is used for assignment.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
require("tidyr")
require("dplyr")
hits.total <- 10 # Assign this value to the hits.total variable. In R, '<-' is used for assignment.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that takes multiple columns and colapses them into key-value pairs.
# The below code takes the columns z1.40 through z3.130 and creates two new columns, 'layer' and 'zl'.
# The 'layer' column consists of many iterations of names of the collapsed columns as keys.
# The 'zl' column consists of values from the collapsed columns.
# The columns, z1.40 through z3.130, are then removed from the data frame.
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
# Separate does just that: it separates a column (in this case, layer) into two or more columns,
# specified using the 'into' argument. The layer column is separated by the '.' character.
hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
# Transform essentially changes a column into a different data type.
# In this context, the 'r' column is originally a string. r=as.numeric(r) changes it into a number type.
hits <- hits %>% transform(r=as.numeric(r))
# Filter returns all rows such that the condition specified as an argument is true.
# Here, we assign make a data frame consisting of all the hits such that: (zl + z < 200 & zl + z > -200).
hits <- hits %>% filter(zl+z<200 & zl+z>-200)
hits <- hits %>% mutate(z=z+zl)
hits
library(dplyr)
hits.total <- 10 # Assign this value to the hits.total variable. In R, '<-' is used for assignment.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that takes multiple columns and colapses them into key-value pairs.
# The below code takes the columns z1.40 through z3.130 and creates two new columns, 'layer' and 'zl'.
# The 'layer' column consists of many iterations of names of the collapsed columns as keys.
# The 'zl' column consists of values from the collapsed columns.
# The columns, z1.40 through z3.130, are then removed from the data frame.
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
# Separate does just that: it separates a column (in this case, layer) into two or more columns,
# specified using the 'into' argument. The layer column is separated by the '.' character.
hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
# Transform essentially changes a column into a different data type.
# In this context, the 'r' column is originally a string. r=as.numeric(r) changes it into a number type.
hits <- hits %>% transform(r=as.numeric(r))
# Filter returns all rows such that the condition specified as an argument is true.
# Here, we assign make a data frame consisting of all the hits such that: (zl + z < 200 & zl + z > -200).
hits <- hits %>% filter(zl+z<200 & zl+z>-200)
hits <- hits %>% mutate(k=z+zl)
hits
hits.total <- 10 # Assign this value to the hits.total variable. In R, '<-' is used for assignment.
id   <- 1 : hits.total # ids is now a list of integers from 1 to hits.total.
z    <- runif(hits.total, -50, 50)  # z is now hits.total elements sampled from a uniform distribution
phi  <- runif(hits.total, 0, 2*pi)  # stretching from -50 to 50. Likewise, phi and eta are hits.total
eta  <- runif(hits.total, 0, 2*pi)  # elements sampled from a uniform distribution [0, 2*pi]
hits <- data.frame(id, z, phi, eta) # Create a data.frame object from our 4 lists.
# Mutate is a function that adds new columns to the data frame.
# Here, we add the new columns z1.40, z2.70, z25.100 and z3.130.
# These columns are defined as lists of elements from eta after some function was applied to them.
# For instance, z1.40[3] = 40 / tan(eta[3]).
hits <- hits %>% mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta))
# Gather is a function that takes multiple columns and colapses them into key-value pairs.
# The below code takes the columns z1.40 through z3.130 and creates two new columns, 'layer' and 'zl'.
# The 'layer' column consists of many iterations of names of the collapsed columns as keys.
# The 'zl' column consists of values from the collapsed columns.
# The columns, z1.40 through z3.130, are then removed from the data frame.
hits <- hits %>% gather(key=layer, value=zl, z1.40:z3.130)
# Separate does just that: it separates a column (in this case, layer) into two or more columns,
# specified using the 'into' argument. The layer column is separated by the '.' character.
hits <- hits %>% separate(layer, into = c("val", "r"), sep = "\\.")
# Transform essentially changes a column into a different data type.
# In this context, the 'r' column is originally a string. r=as.numeric(r) changes it into a number type.
hits <- hits %>% transform(r=as.numeric(r))
# Filter returns all rows such that the condition specified as an argument is true.
# Here, we assign make a data frame consisting of all the hits such that: (zl + z < 200 & zl + z > -200).
hits <- hits %>% filter(zl+z<200 & zl+z>-200)
hits <- hits %>% mutate(z=z+zl)
hits$eta <- NULL
hits$val <- NULL
hits$zl  <- NULL
hits
hits.total <- 10
id   <- 1 : hits.total
z    <- runif(hits.total, -50, 50)
phi  <- runif(hits.total, 0, 2*pi)
eta  <- runif(hits.total, 0, 2*pi)
hits <- data.frame(id, z, phi, eta) %>%
mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta)) %>%
gather(key=layer, value=zl, z1.40:z3.130) %>%
separate(layer, into = c("val", "r"), sep = "\\.") %>%
transform(r=as.numeric(r)) %>%
filter(zl+z<200 & zl+z>-200) %>%
mutate(z=z+zl)
# Remove all unnecessary columns.
hits$eta <- NULL
hits$val <- NULL
hits$zl  <- NULL
hits
hits.total <- 10
id   <- 1 : hits.total
z    <- runif(hits.total, -50, 50)
phi  <- runif(hits.total, 0, 2*pi)
eta  <- runif(hits.total, 0, 2*pi)
hits <- data.frame(id, z, phi, eta) %>%
mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta)) %>%
gather(key=layer, value=zl, z1.40:z3.130) %>%
separate(layer, into = c("val", "r"), sep = "\\.") %>%
transform(r=as.numeric(r)) %>%
mutate(z=z+zl)
filter(z<200 & z>-200) %>%
# Remove all unnecessary columns.
hits$eta <- NULL
?filter
hits.total <- 10
id   <- 1 : hits.total
z    <- runif(hits.total, -50, 50)
phi  <- runif(hits.total, 0, 2*pi)
eta  <- runif(hits.total, 0, 2*pi)
hits <- data.frame(id, z, phi, eta) %>%
mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta)) %>%
gather(key=layer, value=zl, z1.40:z3.130) %>%
separate(layer, into = c("val", "r"), sep = "\\.") %>%
transform(r=as.numeric(r)) %>%
mutate(z=z+zl) %>%
filter(-200 < z & z < 200)
# Remove all unnecessary columns.
hits$eta <- NULL
hits$val <- NULL
hits$zl  <- NULL
hits
hits.total  <- 10
hits.layers <- c(40, 70, 100, 130) # The radiuses of each of the layers.
id   <- 1 : hits.total
z    <- runif(hits.total, -50, 50)
phi  <- runif(hits.total, 0, 2*pi)
eta  <- runif(hits.total, 0, 2*pi)
hits <- data.frame(id, z, phi, eta)
for (layer in hits.layers) {
hits <- hits %>% mutate(z.layer=layer)
}
#          mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta)) %>%
#          gather(key=layer, value=zl, z1.40:z3.130) %>%
#          separate(layer, into = c("val", "r"), sep = "\\.") %>%
#          transform(r=as.numeric(r)) %>%
#          mutate(z=z+zl) %>%
#          filter(-200 < z & z < 200)
# Remove all unnecessary columns.
#hits$eta <- NULL
#hits$val <- NULL
#hits$zl  <- NULL
hits
require("tidyr")
require("dplyr")
require("rgl")
### Generate Linear Tracks ###
hits.total  <- 5000
cluster_id  <- 1 : hits.total
z           <- runif(hits.total, -50, 50)
phi         <- runif(hits.total, 0, 2*pi)
eta         <- runif(hits.total, 0, 2*pi)
hits <- data.frame(cluster_id, z, phi, eta) %>%
mutate(z1.40=40/tan(eta), z2.70=70/tan(eta), z25.100=100/tan(eta), z3.130=130/tan(eta)) %>%
gather(key=layer, value=zl, z1.40:z3.130) %>%
separate(layer, into = c("val", "r"), sep = "\\.") %>%
transform(r=as.numeric(r)) %>%
mutate(z=z+zl) %>%
filter(-200 < z & z < 200)
# Remove all unnecessary columns.
hits$eta <- NULL
hits$val <- NULL
hits$zl  <- NULL
hits <- hits[with(hits, order(cluster_id, r)), ]
rownames(hits) <- NULL
hits
### Save Generated Data to File ###
filename <- ("standard_linear.csv")
write.csv(hits, filename, row.names=TRUE)
### Graphing ###
r<-5
my.t <- rep(seq(-.2,.2,length.out=100), each=3)
my.p <- c(0,0,0)
my.d <- c(40,25,15)
my.o <- my.p + my.t * my.d
my.m <- matrix(my.o, ncol=3,byrow=TRUE)
my.a <- my.d[1]^2 + my.d[2]^2
my.b <- 2 * my.p[1] * my.d[1] + 2 * my.p[2] * my.p[2]
my.c <- my.p[1]^2 + my.p[2]^2 - r^2
my.tp <- (-my.b + sqrt(my.b^2 - 4*my.a*my.c)) / (2*my.a)
my.tn <- (-my.b - sqrt(my.b^2 - 4*my.a*my.c)) / (2*my.a)
plot3d(my.m[,1], my.m[,2], my.m[,3])
my.pos<-(my.p + my.tp * my.d)
my.neg<-(my.p + my.tn * my.d)
points3d(my.pos[1],my.pos[2],my.pos[3],col='red')
points3d(my.neg[1],my.neg[2],my.neg[3],col='red')
th = seq(0,2*pi, length.out=100)
adj <- r * cos(th)
opp <- r * sin(th)
points3d(adj,opp,my.pos[3],col='green')
points3d(adj,opp,my.neg[3],col='green')
require("tidyr")
require("dplyr")
MeV <- read.csv("public_train_100MeV.csv")
MeV <- MeV %>% mutate(phi=atan2(y, x)) %>%
mutate(z=0*cluster_id)
names(MeV)[names(MeV) == "layer"] <- "r"
MeV$layer <- NULL
MeV$x     <- NULL
MeV$y     <- NULL
MeV$iphi  <- NULL
MeV <- MeV[with(MeV, order(event_id, cluster_id, r)), ]
rownames(MeV) <- NULL
MeV
### Save Generated Data to File ###
filename <- ("standard_100MeV.csv")
write.csv(hits, filename, row.names=TRUE)
require("tidyr")
require("dplyr")
MeV <- read.csv("public_train_100MeV.csv")
MeV <- MeV %>% mutate(phi=atan2(y, x)) %>%
mutate(z=0*cluster_id)
names(MeV)[names(MeV) == "layer"] <- "r"
MeV$layer <- NULL
MeV$x     <- NULL
MeV$y     <- NULL
MeV$iphi  <- NULL
MeV <- MeV[with(MeV, order(event_id, cluster_id, r)), ]
require("tidyr")
require("dplyr")
MeV <- read.csv("public_train_100MeV.csv")
MeV <- MeV %>% mutate(phi=atan2(y, x)) %>%
mutate(z=0*cluster_id)
names(MeV)[names(MeV) == "layer"] <- "r"
MeV$layer <- NULL
MeV$x     <- NULL
MeV$y     <- NULL
MeV$iphi  <- NULL
MeV <- MeV[with(MeV, order(event_id, cluster_id, r)), ]
rownames(MeV) <- NULL
MeV
### Save Generated Data to File ###
filename <- ("standard_100MeV.csv")
write.csv(MeV, filename, row.names=TRUE)
